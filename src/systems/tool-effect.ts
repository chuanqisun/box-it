/**
 * Tool Effect System
 *
 * This system processes tool-item collisions and applies effects.
 * It's designed to be extensible for future tool types.
 *
 * Currently supported effects:
 * - "transform": Changes the item's emoji/appearance
 * - "destroy": Removes the item
 * - "slow": Reduces item velocity
 *
 * The system reads collision events generated by the collision system
 * and applies the tool's effect to colliding items.
 */

import type { FeedbackEffect } from "../components";
import type { GameEntity, GameGlobal } from "../domain";
import type { System } from "../engine";

export interface ToolEffectConfig {
  type: "transform" | "destroy" | "slow" | "none";
  value?: unknown;
}

export const toolEffectSystem: System<GameEntity, GameGlobal> = (world, _deltaTime) => {
  // Get collision events
  const collisionEventsEntity = world.entities.find((e) => e.collisionEvents);
  const collisions = collisionEventsEntity?.collisionEvents?.collisions ?? [];

  // Filter for tool-item collisions
  const toolItemCollisions = collisions.filter((c) => c.type === "tool-item");
  if (toolItemCollisions.length === 0) return world;

  // Get all tools with effects
  const toolsWithEffects = world.entities.filter(
    (e) => e.tool?.effect && e.tool.effect.type !== "none"
  );

  if (toolsWithEffects.length === 0) return world;

  // Process each collision and collect effects
  const itemsToModify = new Map<number, ToolEffectConfig>();
  const itemsToRemove: Array<{ id: number; x: number; y: number }> = [];
  const feedbackEffects: FeedbackEffect[] = [];

  for (const collision of toolItemCollisions) {
    const tool = toolsWithEffects.find((t) => t.id === collision.entityId);
    if (!tool?.tool?.effect) continue;

    const effect = tool.tool.effect as ToolEffectConfig;
    const item = world.entities.find((e) => e.id === collision.otherEntityId);

    switch (effect.type) {
      case "destroy":
        if (item?.transform) {
          itemsToRemove.push({ id: collision.otherEntityId, x: item.transform.x, y: item.transform.y });
        }
        break;
      case "transform":
      case "slow":
        itemsToModify.set(collision.otherEntityId, effect);
        if (item?.transform && effect.type === "transform") {
          feedbackEffects.push({
            text: "âœ¨",
            x: item.transform.x,
            y: item.transform.y,
            color: "#ffff00",
            size: 30,
            life: 0.8,
            velocityY: -2,
          });
        }
        break;
    }
  }

  // Apply modifications in a single pass
  if (itemsToModify.size > 0 || feedbackEffects.length > 0) {
    world.updateEntities((entities) =>
      entities.map((entity) => {
        // Apply feedback effects
        if (entity.feedback && feedbackEffects.length > 0) {
          return {
            ...entity,
            feedback: {
              ...entity.feedback,
              effects: [...entity.feedback.effects, ...feedbackEffects],
            },
          };
        }

        // Apply item modifications
        const effect = itemsToModify.get(entity.id);
        if (!effect) return entity;

        switch (effect.type) {
          case "transform":
            if (typeof effect.value === "string" && entity.render) {
              return {
                ...entity,
                render: { ...entity.render, emoji: effect.value },
                name: { value: effect.value },
              };
            }
            return entity;

          case "slow":
            if (entity.velocity) {
              const slowFactor = typeof effect.value === "number" ? effect.value : 0.5;
              return {
                ...entity,
                velocity: {
                  ...entity.velocity,
                  x: entity.velocity.x * slowFactor,
                  y: entity.velocity.y * slowFactor,
                },
              };
            }
            return entity;

          default:
            return entity;
        }
      })
    );
  }

  // Remove destroyed items and add destruction feedback
  if (itemsToRemove.length > 0) {
    const destructionFeedback: FeedbackEffect[] = itemsToRemove.map((item) => ({
      text: "ðŸ’¥",
      x: item.x,
      y: item.y,
      color: "#ff4444",
      size: 40,
      life: 0.6,
      velocityY: -1,
    }));

    // Add destruction feedback
    world.updateEntities((entities) =>
      entities.map((e) => {
        if (e.feedback) {
          return {
            ...e,
            feedback: {
              ...e.feedback,
              effects: [...e.feedback.effects, ...destructionFeedback],
            },
          };
        }
        return e;
      })
    );

    // Remove items after capturing their positions
    for (const item of itemsToRemove) {
      world.removeEntity(item.id);
    }
  }

  return world;
};
